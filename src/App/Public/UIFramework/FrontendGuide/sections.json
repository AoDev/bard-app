[
  {
    "id": "frontend-01-intro",
    "title": "Introduction: Clean Frontend Architecture",
    "content": "# Introduction: Clean Frontend Architecture\n\nThere are infinite ways to build frontend and software in general. Thus the solution to a maintainable architecture is not in the details but in a solid foundation built from a simple and small set of guidelines that are easy to keep in check.\n\n**You can always fix a bug in a library, but a bad architecture will turn your entire project into Hell.**\n\n**A clean architecture tries to divide the entire system in layers and entities that have their own responsibility.**\n\n> Simpler is better. Less is more.\n\n---\n\n[Next: \"A Frontend SPA Recipe\"](frontend-02-spa-recipe-principles.md)\n"
  },
  {
    "id": "frontend-02-spa-recipe-principles",
    "title": "A Frontend SPA Recipe",
    "content": "# A Frontend SPA Recipe\n\nWhat follows is a single page app (SPA) recipe that is continously evolving by keeping in mind the [\"Keep it Simple, Stupid principle\" (KISS)](https://en.wikipedia.org/wiki/KISS_principle).\n\n## The Recipe Ingredients\n\n1. **React + Mobx**. \"Pure\" Mobx is used, mainly for simplicity and flexibility.  \n   (There are opiniated solutions like [Mobx State Tree](https://mobx-state-tree.js.org/intro/philosophy)).\n\n2. **3 principles** influence the frontend architecture itself (not just react / mobx):\n\n- [Clean architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) by Robert C. Martin (Uncle Bob)\n- [Decouple state and UI article](https://hackernoon.com/how-to-decouple-state-and-ui-a-k-a-you-dont-need-componentwillmount-cc90b787aa37) by Michel Weststrate (Mobx creator)\n- [App shell architecture](https://developers.google.com/web/fundamentals/architecture/app-shell) on developers.google.com.\n\n3. **Building a UI Framework**.  \n   The framework encapsulates all the reusable styles and UI components, boosting consistency and productivity.\n\nI recommend to have a look at these links in your \"free time\" if such thing exists for a developer ;)\n\n---\n\n[Next: \"The Mobx / React combo\"](frontend-03-1-intro_mobx-react.md)\n"
  },
  {
    "id": "frontend-03-1-intro_mobx-react",
    "title": "The Mobx / React combo",
    "content": "# The Mobx / React combo\n\n- We have external stores where our data is made **observable** with Mobx.\n- React UI components **observe** the data and **update automatically**.\n\n> We use the observer pattern to make React trully reactive.\n\n## About Mobx\n\nMobx official docs are [here](http://mobx.js.org/).  \nMobx itself is a library that lets you implement business logic following the **observer pattern**.\n\n### Mobx is NOT a Framework\n\nIt does not impose, nor help you with structuring your code.  \n_There are many ways to use Mobx_ to write React App.\n\nMobx' goal is to provide an **easy way** to deal with observables.\nIt is that simplicity of use that makes it powerful and enjoyable at the same time. ([Transparent Functional Reactive Programming](https://medium.com/hackernoon/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.9aufnt6up))\n\n\n## Principles we are trying to model\n\nWe strongly emphasize that business data and UI states are two different things.  \nWe follow the [MVVM pattern](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel). (Model View View-Model)\n\n- The app data (layer) is in external stores while the UI components state are in a VM (view-model).\n\n- We like simple: there is little to no difference to manage local UI state and app data.\n  - A VM is also a store but, it's local, temporary and connects external store to components.\n  - We don't need react internal state most of the time. (no hooks or classes setState)\n  - We just need to know javascript and a couple of things from Mobx.\n\n- We like a single source of truth and most components to be [controlled from outside](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components).\n\n- The appearance of the UI is implemented in a UI Framework (Styles and components library).\n\n<img width=\"576\" alt=\"frontend-layers\" src=\"https://user-images.githubusercontent.com/1526150/107215672-ea1ebe80-6a0b-11eb-9c47-9630179875b2.png\">\n\n**Another way to explain the clear separation of concerns**\n\nEven though the UI is built to match the data, UI and data are separate layers. You should be able to throw away your entire UI without touching the stores or throw away the stores and feed the data to your UI in a different way.\n\n> The external stores (= data layer) live on their own and don't need the UI for the business goal to be achieved.\n\n---\n\n[Next: \"Structure of the data layer (mobx-react)\"](frontend-03-2-structure-of-datalayer_mobx-react.md)\n"
  },
  {
    "id": "frontend-03-2-structure-of-datalayer_mobx-react",
    "title": "Structure of the data layer",
    "content": "# Structure of the data layer\n\n**Reminder**: One goal of this recipe is to separate data management from UI components as much as possible.\nThis way, React components become simple reactive \"templates\".\n\n**There are 3 levels**\n\n- RootStore\n- \"Feature\" stores\n- \"Models\"\n\n<img width=\"450\" alt=\"3-layers-stores\" src=\"https://user-images.githubusercontent.com/1526150/118300431-346b7c00-b4e2-11eb-812d-8eec8c6e7b61.png\">\n\nAll of these are implemented using the observable capabilities of Mobx.\n\n## RootStore: where everything starts\n\nThe **RootStore** is the backbone of the data layer.\n\nIt is responsible:\n\n- for instantiating and connecting the other stores between themselves.\n- for allowing the app state to be shared to the UI layer.\n- for implementing use cases (or user stories) that depend on multiple stores.\n\n## \"Feature\" stores\n\nThey hold and manipulate the state for a particular feature.\nBy feature I don't mean a small thing but rather something like:\n\n- a `userStore` to represent everything about the user\n- a `paymentStore` to model, check and list payments\n- a `productStore` to fetch, save and filter the list of products\n- ...\n\nDepending on your app, you'll have clearly defined features that are usually matching a page / screen.\n\n## Models\n\nModels and stores are kind of the same thing but a model in our context is a small standalone entity.\n\nLike the _ProductStore_ has a list of _ProductModels_.\n\n\nNote, we don't need to wrap data in \"models\" all the time. In fact, most of the time it isn't needed.\nFor example you could have a product store and its list of products is just a normal array.\n\n```ts\ntype Product = {id: number; name: string; ...}\n\nclass ProductStore {\n  products: Product[] = [{id: 1, name: 'name', ...}]\n}\n```\n\n> A model has only one responsibility. It represents one single \"thing\".\n> A store can be interacting with all kinds of smaller models to implement a business use case.\n\n---\n\n[Next: \"What is a (Mobx) store at code level? (mobx-react)\"](frontend-03-3-data-stores-code_mobx-react.md)\n"
  },
  {
    "id": "frontend-03-3-data-stores-code_mobx-react",
    "title": "What is a (Mobx) store at code level?",
    "content": "# What is a (Mobx) store at code level?\n\nA store is an ES6 class. It has properties and methods to get, hold and manipulate data for a **specific** area of the business. eg: userStore, productStore, ...\n\n_Note_: Mobx can work with plain objects as well, but classes give us some advantages, so we will always use classes. ([See: a short note on classes](https://mobx.js.org/observable-state.html#a-short-note-on-classes))\n\n_Conclusion_: \"stores\" are just \"models\" supercharged with observable capabilities thanks to Mobx.\n\n## Typical store structure\n\n```ts\nimport * as mobx from 'mobx'\n\nexport default class MyStore {\n  myValue = true\n\n  get myValueNegated() {\n    return !this.myValue\n  }\n\n  changeMyValue(newValue: boolean) {\n    this.myValue = newValue\n  }\n\n  constructor(rootStore) {\n    this.rootStore = rootStore\n\n    // (*) Explanation below\n    mobx.makeAutoObservable(this, undefined, {autoBind: true, deep: false})\n  }\n}\n```\n\n## The one magic line\n\n```ts\nmobx.makeAutoObservable(this, undefined, {autoBind: true, deep: false})\n```\n\nThis one liner that we put in class constructors gives the class observable capabilities:\n\n- properties will become [observable values](https://mobx.js.org/observable-state.html#creating-observable-state).\n- methods become [mobx actions](https://mobx.js.org/actions.html).\n- getters become [computed values](https://mobx.js.org/computeds.html).\n\nIn 90% of cases you will want **to use the exact same options that were in the example above**.\n\n**In details**\n\n- `undefined` (the second argument): is meant to override the *\"auto\"* of `makeAutoObservable`.\n\n  **In Practice**: it can happen that we don't want a particular property to become observable.  \n  eg: `makeAutoObservable(this, {myProp: false})` but we rarely need to do this.\n\n- `autoBind: true`: will bind the methods to the instance (the `this` value).\n\n  **In practice**: manually binding the `this` value is typically needed when a method is set on a DOM element like a _button onClick handler_. This solves it for us. No need for arrow functions or to call `fn.bind(this)`. (eg: `this.changeMyValue = this.changeMyValue.bind(this)`)\n\n- `deep: false`: the observable changes are limited at the **reference** level only.\n\n  **In practice**: Mobx has [different \"observation levels\"](https://mobx.js.org/observable-state.html#available-annotations) to track values. Setting `deep` to false is **a sane default**. We basically only track reference change. For example: `array.push()` won't trigger an observable change, because the array reference has not changed. Instead we would set a new array that contains the updates. It is a more functional approach (less mutation, more performant and compatible with other apis).\n\n---\n\n[Next: \"What is a VM - View-Model? (mobx-react)\"](frontend-03-3-view-models_mobx-react.md)\n"
  },
  {
    "id": "frontend-03-3-view-models_mobx-react",
    "title": "What is a VM - View-Model?",
    "content": "# What is a VM - View-Model?\n\nWe want a simple life. So, a VM implementation is basically the same as an external store.\n\n**It is a store but it's a temporary one**.\n\nIt is meant to be local state and / or a connector between the data layer and the UI components. Where you put click handlers or values of form inputs, etc...\n\nThey are typically created per feature sections or when the UI becomes complex and need to be split in smaller units. Like `productVM` for the part of an app that would deal with products.\n\n\n## The advantage of this approach\n\n**In short: it is much simpler.**\n\n- **You can use \"vanilla\" javascript** to build your logic. No need to learn extra API's and dealing with the caveats of React such as `hooks` or classes `setState`. Or even the need for a 3rd party that requires to learn their own API's.\n\n- **Same code pattern everywhere**  \n  The way to code local state and global app state are the same. (declarative observable stores)\n\n\n> A VM is a connector between the View Layer and the Data Layer and is used as local state.\n\n\n---\n\n[Next: \"How the data flows throughout the app (mobx-react)\"](frontend-03-4-data-flow_mobx-react.md)\n"
  },
  {
    "id": "frontend-03-4-data-flow_mobx-react",
    "title": "Passing data to UI components",
    "content": "# Passing data to UI components\n\n## How React components get the stores data?\n\nMobx has a specific lib for React data binding. It is called [Mobx-React](https://github.com/mobxjs/mobx/tree/main/packages/mobx-react)\nIt exposes utilities like `observer`, `provider` and `inject`.\n\nNote that over time, developers have changed their mind about how to write React apps. (flux, event emitters, HOC, classes, hooks, context,...)\nThe same happened to Mobx. `provider` and `inject` are not \"fashion enough\" nowadays. **This recipe keeps using `provider` and `inject`**.\n\n### Using the \"withVM\" utility\n\n`withVM` was created to make dev life easier. It runs the necessary logic to connect UI components + VM + external data stores.\n\nUnder the hood it is using mobx-react `inject`, which in turn, is using `React Context`.\n\n## Differences with stand alone React when passing props\n\nWith stand alone React, we are used to pass multiple props to components. With Mobx, we pass entire objects (stores and models) that are observable.\n\nHere is a contrieved example:\n\n**React stand alone**\n\n```tsx\n// Component\nfunction UserDetails (props) {\n  return (\n    <div>{props.firstName} {props.lastName} {props.age}</div>\n  )\n}\n\n// Usage\n<UserDetails firstName=\"John\" lastName=\"Doe\" age={20}>\n```\n\n**Mobx-react**\n\n```tsx\n// Component\nfunction UserDetails (props) {\n  return (\n    <div>{user.firstName} {user.lastName} {user.age}</div>\n  )\n}\n\n// Usage\n<UserDetails user={user}>\n```\n\nWe will have 99% of our components as `observers`.\nWe will provide the app state (data layer) with `inject`.\n\n---\n\n[Next: \"App feature gist\"](frontend-04-feature-gist.md)\n"
  },
  {
    "id": "frontend-04-feature-gist",
    "title": "A Frontend Recipe: Gist",
    "content": "# A Frontend Recipe: Gist\n\nAlmost no explanations, very summarized guide through a pseudo code example.\n\n<img width=\"576\" alt=\"frontend-layers\" src=\"https://user-images.githubusercontent.com/1526150/107215672-ea1ebe80-6a0b-11eb-9c47-9630179875b2.png\">\n\n## File Structure\n\n```\nsrc/\n  index.tsx\n\n  App/\n    Feature/\n      index.ts\n      Feature.less\n      Feature.tsx\n      FeatureItemList.tsx\n      FeatureVM.ts\n\n  stores/\n    RootStore.ts\n    UIStore.ts\n    FeatureStore.ts\n\n  styles/\n    index.less\n\n  ui-framework/\n    components/\n      Button.js\n      Button.less\n\n    styles/\n      index.less\n\n      elements/\n        buttons.less\n        panels.less\n```\n\n_Note the naming conventions. Folder, styles, VM, Component with same name..._\n\n**src/index.tsx**\n\nWhere app is bootstrapped, UI mounted, RootStore instantiated.\n\n```tsx\nimport {Provider} from 'mobx-react'\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport './styles/index.scss'\n\nconst rootStore = new RootStore()\n\nReactDOM.render(\n  <Provider rootStore={rootStore}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n```\n\n## App/\n\n**App.tsx**\n\n= Root Component\n\n```tsx\nimport React from 'react'\nimport Feature from './Feature'\n\nexport default function App() {\n  return (\n    <div>\n      <h1>My App</h1>\n      <Feature />\n    </div>\n  )\n}\n```\n\n## App/Feature/\n\n**index.ts**\n\n= exports a component (Feature) connected to external stores through a VM\n\n```ts\nimport withVM from 'app-lib/withVM'\nimport Feature from './Feature'\nimport FeatureVM from './FeatureVM'\nexport default withVM(Feature, FeatureVM)\n```\n\n**FeatureVM.ts**\n\n= local store(state) + provide access to external store.\n\n```ts\nimport * as mobx from 'mobx'\nimport {RootStore, FeatureStore} from 'src/stores'\n\nexport default class FeatureVM {\n  public rootStore: RootStore\n  public featureStore: FeatureStore\n\n  public word = 'World'\n\n  public changeWord() {\n    this.word = 'There'\n  }\n\n  constructor({rootStore}: {rootStore: RootStore}) {\n    this.rootStore = rootStore\n    this.featureStore = rootStore.featureStore\n    mobx.makeAutoObservable(this, undefined, {autoBind: true, deep: false})\n  }\n}\n```\n\n**Feature.tsx**\n\n= UI for the feature\n\n```tsx\nimport React from 'react'\nimport FeatureVM from './FeatureVM'\nimport FeatureItemList from './FeatureItemList'\nimport {Button} from 'ui-framework'\n\nexport default class Feature ({vm} : {vm: FeatureVM}) {\n  return (\n    <div className='panel'>\n      Hello {vm.word}\n\n      <Button onClick={vm.changeWord}>\n        Change word\n      </Button>\n\n      <div className='feature__very-specific-style'>\n        <FeatureItemList vm={vm}>\n      </div>\n    </div>\n  )\n}\n```\n\n**FeatureItemList.tsx**\n\n= sub component for the feature. Receives the vm through props from parent component.\n\n```tsx\nimport React from 'react'\nimport FeatureVM from './FeatureVM'\n\nexport class Feature {{vm} : {vm: FeatureVM}} {\n  return (\n    <div>\n      {vm.featureStore.list.map((item) => <div>{item.data}</div>)}\n    </div>\n  )\n}\n\nexport default observer(FeatureItemList)\n```\n\n**Feature.scss** (optional)\n\n= specific styles for the feature UI if needed.\n\n```scss\n.feature__very-specific-style {\n  position: absolute;\n  top: 100px;\n}\n```\n\n## /stores\n\n**FeatureStore.ts**\n\n= app state for a particular business use case\n\n```ts\nimport * as mobx from 'mobx'\n\nexport default class FeatureStore {\n  list = []\n\n  constructor(rootStore: RootStore) {\n    this.rootStore = RootStore\n    mobx.makeAutoObservable(this, undefined, {autoBind: true, deep: false})\n  }\n}\n```\n\n**RootStore.ts**\n\n= app root state.\n\n- Injected in UI components with `withVM` util. (React Context)\n- Instantiates other stores.\n\n```ts\nimport * as mobx from 'mobx'\nimport FeatureStore from './FeatureStore'\n\nexport default class RootStore {\n  constructor() {\n    this.featureStore = new FeatureStore(this)\n    mobx.makeAutoObservable(this, undefined, {autoBind: true, deep: false})\n  }\n}\n```\n\n## /styles\n\n**index.scss**\n\n= imports all styles from ui framework and app specific.\n\n```scss\n@import '../ui-framework/styles/index.scss';\n\n@import '../App/Feature/Feature.scss';\n```\n\n---\n\n[Next: \"Code guidelines\"](frontend-05-code-guidelines.md)\n"
  },
  {
    "id": "frontend-05-ui-framework",
    "title": "UI Framework",
    "content": "# UI Framework\n\nComposed of **React components** and **CSS styles**.\n\n## Goals\n\nThe key is to think \"generic\" first to achieve consistency, DRY code and level up productivity.\n\n**Develop faster and easier** with reusable generic components (buttons, etc) and a css architecture that scales.\n\n**Reduce code (DRY)**: if done properly, an application entire CSS can be very small with\n\n- 80% coming from ui-framework\n- 20% specific styles (feature specific).\n\n## Layers\n\n<img width=\"1186\" alt=\"ui-layers-01\" src=\"https://user-images.githubusercontent.com/1526150/107490882-c2099980-6b8a-11eb-990d-20972eb51f13.png\">\n\n## CSS styles architecture\n\nCSS themselves have their own architecture based on [Atomic CSS classes](https://css-tricks.com/lets-define-exactly-atomic-css/).\n\n- **Avoids mixing appearance, positioning and functional styles.**\n- **Leverage composition of classes** to achieve goals.  \n  eg: `<div class=\"bg--light border--rounded shadow-1\"/>`\n\n### Variables and pre-processors\n\nPre-processors allow us to write CSS more easily.\n\nThe language does not really matter: [less](http://lesscss.org/) or [sass](https://sass-lang.com/) are fine. But the code examples use `less`.\n\n- variables are found in the `variable.less` file and can be changed easily to customize elements.\n\n### Divided in 3 main categories\n\n- **cosmetic**: classes dedicated to specific appearance attributes such as _borders_ or _backgrounds_.\n\n- **elements**: classes dedicated to identifiable elements such as _buttons_, _tables_ or _inputs_.\n\n- **layout**: classes dedicated to positioning and spacing such as _grid_, _flex_, _margins_ or _padding_.\n\n  For easier maintainability, layout is split into 2 categories:\n\n  - **layout-self**: classes affects the element itself.\n  - **layout-children**: classes affects the children of the element.\n\n### Other CSS classes\n\n- _utils_: other classes that may alter _behaviour_ or _visibility_ that don't fit well in the 3 main categories.\n\n- _reset_:\n  - some general resets for elements such as img, body, html...\n  - note: the framework uses [normalize.css](https://necolas.github.io/normalize.css/) to reset some elements.\n\n**Components styles**\n\nThere are UI elements that works only with javascript so they are encapsulated in React components.\n\nThey may need specific styles that wouldn't really exist without the React component. So it sometimes makes sense to define their styles in a `*.less` file located in their folder.\n\n_eg: the Switch component has a `Switch.js` and a `Switch.less` for the styles._\n\n### How the Framework exports its styles\n\nThe different CSS classes of the framework are imported and reexported in an index file.\n\nThis is the `ui-framework/styles/index.less` file.\n\nIt looks like this:\n\n```less\n// ...\n\n// Layout\n@import \"./layout/layout-children\";\n@import \"./layout/...\";\n\n// Cosmetic\n@import \"./cosmetic/backgrounds\";\n@import \"./cosmetic/...\";\n\n// Elements\n@import \"./elements/buttons\";\n@import \"./elements/...\";\n\n// Components\n@import \"../components/Icon/Icon\";\n@import \"../components/...\";\n```\n\n### Integration of the framework CSS in the app\n\nThe application has a style entry point: `src/styles/index.less`.\n\nThis file imports:\n\n- app components specific styles\n- framework styles\n\nIt looks like this:\n\n```less\n@import \"../ui-framework/styles/variables.less\";\n@import \"./variables.less\";\n@import \"../ui-framework/styles/index.less\";\n@import \"./reset.less\";\n// + app specific styles\n```\n\nAs you can see, the app may have another `variables.less` file that may add new variables or overwrite the framework ones.\n\n**The order of import matters**\n\nBecause the framework is imported first, our app specific components and app specific styles also can use the less.js mixins / variables, from it.\n\n### Final words about the framework CSS\n\nThere is **NO \"CSS in JS\"** on purpose. There is more control, ease of maintainance and code reuse possible by keeping the CSS layer isolated.\n\n## React Components\n\nThese are simply generic components that encapsulate extra functionality and allows to write things only once.\n\nExamples: `<Button/>, <Switch/>, <Modal/>`\n\n### How the framework exports the components\n\nThey are exported through an index.js file.\n\n```js\nexport { default as Breadcrumbs } from \"./Breadcrumbs\";\nexport { default as Button } from \"./Button\";\nexport { default as Callout } from \"./Callout\";\nexport { default as Icon } from \"./Icon\";\nexport { default as Loader } from \"./Loader\";\nexport { default as ConfirmDialog } from \"./ConfirmDialog\";\nexport { default as Modal } from \"./Modal\";\n// ...\n```\n\n### Integration in the app\n\nAn alias can be setup in the application, or the framework can be published as a standalone package.\n\nIn both cases, using a component is as simple as:\n\n```jsx\nimport { Button } from \"ui-framework\";\n\nexport default function MyFeature() {\n  return (\n    <div>\n      <Button>Click Me</Button>\n    </div>\n  );\n}\n```\n\n---\n\n[Next: \"CSS Rules\"](frontend-07-css-rules.md)\n"
  },
  {
    "id": "frontend-06-code-guidelines",
    "title": "Code guidelines",
    "content": "# Code guidelines\n\n## Code style\n\nIs enforced through a linter and formatters like eslint, biome, prettier (I switched to biome).\n\n**Recommended**\n\nSetup your editor properly.\n\n- get linting warnings as you type.\n- run code formatting automatically on save.\n\n---\n\n[Next: \"UI framework importance\"](frontend-06-ui-framework.md)\n"
  },
  {
    "id": "frontend-07-css-rules",
    "title": "CSS Rules",
    "content": "# CSS Rules\n\nThe main philosophy is to use atomic classes. (Similar to tailwind css)\n90% of CSS should come from the framework. The rest are specfic to the app.\n\n* Global CSS is defined in the ui-framework as a set of atomic classes always available.\n* Local CSS is defined close to the component code, often using BEM syntax.\n\n## Tooling\n\nI prefer using pre-processors like less or sass. CSS in js solutions, styled components, they tend to discard the philosophy of CSS completely. Promoting inline styling disguised as \"component\" and leaky abstraction.\n\n## Rules\n\nThese are rules to make CSS easily maintained, keep mental sanity and scale for big apps.\nThere are always exceptions, it's normal. But 95% of the time, the rule shouldn't be broken.\n\n\n### Rule 1: Component CSS should not be modified from the outside world.\n\nA component in this case, is a bunch of nested html tags with different classes.\n\nFor example a \"loader component\":\n\n```html\n<div class=\"loader\">\n  <div class=\"loader__inner\">\n    <div class=\"loader__dot\" />\n    <div class=\"loader__dot\" />\n    <div class=\"loader__dot\" />\n  </div>\n</div>\n```\n\nMeans that loader**inner, loader**dot classes, should not be changed from outside.\n\neg: **forbidden**\n\n```css\n.my-page .loader__dot {\n  color: red;\n}\n```\n\nA component should be considered a black box from outside. Of course, there are exceptions.\n\n### Rule 2: Avoid nesting and descendant selectors\n\n```less\n// BAD\n.parent {\n  .child {\n    color: #000;\n  }\n}\n\n// BETTER (BEM)\n.parent__child {\n  color: #000;\n}\n```\n\nReason: this avoids unexpected side effects when elements are placed in different containers.\n\n### Rule 3: Avoid targeting HTML elements\n\n_BAD_\n\n```less\n.parent span {\n  color: #000;\n}\n```\n\n```html\n<div className=\"parent\">\n  <span>Description</span>\n</div>\n```\n\n_BETTER_\n\n```less\n.parent__description {\n  color: #000;\n}\n```\n\n```html\n<div className=\"parent\">\n  <span className=\"parent__description\">Description</span>\n</div>\n```\n\nReason:\n\n- avoids unexpected side effects when elements are placed in different containers\n\n### Rule 3: Avoid nesting of class names composition\n\nPreprocessors allow to write code like this:\n\n```less\n// BAD\n.parent {\n  &__child {\n    color: #000;\n  }\n  &__other {\n    color: #000;\n  }\n}\n\nAvoid this magic and write it like this:\n\n// Correct\n.parent__child {\n  color: #000;\n}\n.parent__other {\n  color: #000;\n}\n```\n\nReason: finding the actual class in the code base is a nightmare.\n\n---\n\n[Next: \"Design accessibility in mind\"](frontend-08-design-aim-colors.md)\n"
  },
  {
    "id": "frontend-08-design-aim-colors",
    "title": "Accessibility and Design",
    "content": "# Accessibility and Design\n\nSimple steps from design to code. For designers, product managers and frontend developers who care about accessibility in their apps.\n\n> \"Great Web Accessibility starts in the design [webaim.org]\"\n\n## Did you know?\n\n_Typography_ has been studied for centuries: effective communication is key to achieve success.\n\nBut, _\"I can read it, so it's fine\"_ is a usual comment in apps development.\nEveryone's vision is different and all screens aren't the same. Thus, the meaning of \"readable\" from a person's point of view is subjective.\n\nIn fact, a lot of people have vision problems.\n\nHave you ever seen how some people have literally their nose on their mobile in public transports?\n\n* In the US, nearly 4.2 million people over age 40 have a visual impairment. Among those 40 and older, more than 2.9 million have low vision and 1.3 million are legally blind.\n\n* Approximately 8% of men and 0.5% of women among populations with Northern European ancestry have the most common form of color blindness that makes it hard to see red or green.\n\nAs developers we can make our user's life easier. That said, it is not only about accessibility. A UI carefully designed with accessibility in mind is pleasant to use for everyone.\n\n> \"A powerful design is not just beautiful, it is also readable.\"\n\n\n## Accessibility Guidelines and AIM tools\n\nInstead of using our own perception, we can rely on the [Web Content Accessibility Guidelines (WCAG)](https://www.w3.org/WAI/standards-guidelines/wcag/).\n\n> \"Web Content Accessibility Guidelines (WCAG) is developed through the W3C process in cooperation with individuals and organizations around the world, with a goal of providing a single shared standard for web content accessibility that meets the needs of individuals, organizations, and governments internationally.\"\n\n## What is an \"AIM color\"?\n\nAIM stands for \"Accessibility In Mind\". (https://webaim.org/)\n\nAn \"AIM color\" is meant to ensure that from a *Contrast* and *Font Size* point of view, a text will be readable in your application.\n\n### The WCAG 2 \"Contrast Ratio\"\n\n> \"In WCAG 2, contrast is a measure of the difference in perceived \"luminance\" or brightness between two colors (the phrase \"color contrast\" is never used). This brightness difference is expressed as a ratio ranging from 1:1 (e.g. white text on a white background) to 21:1 (e.g., black text on a white background)...\" [https://webaim.org/articles/contrast/](webaim.org)\n\n\n\n## Using the Contrast Checker tool\n\nWhen designing, you can use the [Contrast Checker Tool](https://webaim.org/resources/contrastchecker/).\n\nAs you will see, there are different levels of accessibility: AA and AAA.\nHow far you want or need to go is up to you. I recommend to at least pass the WCAG AA for large Text.\n\nThis applies not only to text, but to the UI icons as well.\n\n<img width=\"600\" alt=\"Screenshot 2020-11-30 at 11 30 21\" src=\"https://user-images.githubusercontent.com/1526150/100598828-89824f80-32ff-11eb-8e28-1bcc47931a59.png\"/>\n\n## Resources\n\n* https://www.aao.org/newsroom/eye-health-statistics\n* https://www.healthmarkets.com/resources/supplemental-health-insurance/eye-disease-vision-statistics-infographic/\n* https://webaim.org/resources/designers/"
  }
]
